import cv2
import glob
import numpy as np 
import scipy.ndimage
import tqdm
from scipy.ndimage import imread
from numpy import loadtxt
from multiprocessing import Pool
from tempfile import TemporaryFile


def load_xyz(filename):
	"""Return image data from a PGM file generated by blensor. """
	fx = 472.92840576171875
	fy = fx 
	with open(filename, 'rb') as f:
		f.readline()
		f.readline()
		width_height = f.readline().strip().split()
		if len(width_height) > 1:
		  width, height = map(int,width_height)
		  value_max_range = float(f.readline())
		  image_ = [float(line.strip()) for line in f.readlines()]
		  if len(image_) == height * width:
			nx,ny = (width,height)
			x_index = np.linspace(0,width-1,width)
			y_index = np.linspace(0,height-1,height)
			xx,yy = np.meshgrid(x_index,y_index)
			xx -= float(width)/2
			yy -= float(height)/2
			xx /= fx
			yy /= fy

			cam_z = np.reshape(image_,(height, width))
			cam_z = cam_z / value_max_range * 1.5
			cam_x = xx * cam_z 
			cam_y = yy * cam_z
			image_z = np.flipud(cam_z)
			image_y = np.flipud(cam_y)
			image_x = np.flipud(cam_x)

			zoom_scale = 0.5
			image_x = scipy.ndimage.zoom(image_x, zoom_scale, order=1)
			image_y = scipy.ndimage.zoom(image_y, zoom_scale, order=1)
			image_z = scipy.ndimage.zoom(image_z, zoom_scale, order=1)
			image = np.dstack((image_x,image_y,image_z))
			return image

	return np.zeros((h,w,3))
def normalize(A):
	norm = np.linalg.norm(A,axis=2)
	norm[norm==0] = 1
	return np.divide(A, np.tile(norm[:,:,np.newaxis],(1,1,3)))

def EPE_AAE(i):
	dir = '../'+str(i)
	dir2 = str(i)

	bool_f = 0

	for file in glob.glob(dir + '/pred_frame1_xyz.npz'):
		# print file 
		gt = np.load(file)['flow']
		bool_f = 1

	for file in glob.glob(dir + '/frame80*.pgm'):
		# print file 
		bool_f = bool_f *1
		f_80 = load_xyz(file)

	for file in glob.glob(dir2+'/*_results01.txt'):
		# print file 
		# print file 
		pred = loadtxt(file, comments="#",
			 	delimiter=" ", unpack=False)
		bool_f = bool_f*1
		pred_xyz = pred[:,2:5].reshape((240,320,3))
	
	if bool_f:
		mask = (np.sum(np.abs(gt),axis=2)>0)
		flag = np.tile(mask[:,:,np.newaxis],(1,1,3))
		sf_ground = np.multiply(gt - f_80,flag)

		diff = pred_xyz - sf_ground
		epe = np.mean(np.linalg.norm(diff,axis = 2))

		# print epe 
		pred_xyz4 =1* np.ones((240,320,4))
		pred_xyz4[:,:,0:3] = pred_xyz
		pred_xyz_n = normalize(pred_xyz)
		sf_ground4 =1* np.ones((240,320,4))
		sf_ground4[:,:,0:3] = sf_ground
		sf_ground_n = normalize(sf_ground)

		diff_angle = (180.0/np.pi)*np.arccos(np.divide(
				np.sum(np.multiply(pred_xyz4,sf_ground4),axis=2),
				np.multiply(np.linalg.norm(pred_xyz4,axis=2), 
					np.linalg.norm(sf_ground4,axis=2))))
		
		diff_angle_masked = (180.0/np.pi)*np.arccos(np.sum(
					np.multiply(sf_ground_n, pred_xyz_n),axis=2))
		mask2 = (np.sum(np.abs(gt),axis=2)>1e-6)
		diff_angle_masked = np.multiply(mask2,diff_angle_masked)
		
		aae = np.mean(diff_angle)

		aae_masked = (np.sum(diff_angle_masked))/(np.sum(mask2)+1)
                # print aae_masked

		return  bool_f,epe,aae,aae_masked
	return bool_f, -1,-1,-1

### MAIN
N = 8500
# global EPE, AAE
# EPE = np.zeros(N)
# AAE = np.zeros(N)


# with open("EPE_output.txt", "w") as text_file:
folders = [i for i in range(N)]
# print folders


EPE = []
AAE = []
AAE_masked = []
valid = []
pool = Pool(10)
for i,dat in tqdm.tqdm(enumerate(pool.imap(EPE_AAE,folders))):
	valid.append(dat[0])
	if dat[0]:
		EPE.append(dat[1])
		AAE.append(dat[2])
		AAE_masked.append(dat[3])
	else:
		print i 
	# print i

pool.close()
# pool.join()

np.savez('EPE_AAE',AAE= AAE, EPE = EPE, AAE_masked = AAE_masked)
print np.mean(EPE)
print np.mean(AAE)
print np.mean(AAE_masked)
# file = np.load('5/pred_frame1_xyz.npz')
# gt = file['flow']
# print gt.shape

# for name in glob.glob('5/frame80*.pgm'):
# 	f_80 = load_xyz(name)

# pred = loadtxt('5/5_results01.txt', comments="#", delimiter=" ", unpack=False)

# pred_xyz = pred[:,2:5].reshape((240,320,3))

